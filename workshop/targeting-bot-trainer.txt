settings
{
	modes
	{
		Skirmish
		{
			enabled maps
			{
				Workshop Chamber
			}
		}

		General
		{
			Limit Roles: 2 Of Each Role Per Team
		}
	}
}

variables
{
	global:
		0: game_name
		1: team_1_spawn_direction
		2: team_2_spawn_direction
		3: team_1_spawn_positions
		4: team_2_spawn_positions
		5: targeting_interval
		6: bot_turn_rate
		7: hud_notifications_duration
		8: hud_notifications_sort_order

	player:
		0: bot_targeted_enemy
		1: primary_fire_cooldown
		2: primary_fire_max_range
		3: hud_notifications
}

subroutines
{
	0: AddLastTextToPlayerNotifications
}

rule("Workshop settings")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.bot_turn_rate = Workshop Setting Integer(Custom String("General"), Custom String("Bot turn rate"), 400, 200, 1000, 10);
		Global.targeting_interval = Workshop Setting Real(Custom String("General"), Custom String("Targeting interval [seconds]"), 0.500,
			0.200, 1, 20);
		Global.hud_notifications_duration = Workshop Setting Integer(Custom String("HUD - Notifications"), Custom String(
			"Notification duration [seconds]"), 5, 5, 20, 10);
	}
}

rule("Initialize global variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.game_name = Custom String("Targeting Bot Trainer");
		Global.hud_notifications_sort_order = 1000;
		Global.team_1_spawn_direction = Vector(-1, 0, 0);
		Global.team_2_spawn_direction = Vector(1, 0, 0);
		Global.team_1_spawn_positions[0] = Vector(15, 0, 0);
		Global.team_1_spawn_positions[1] = Vector(15, 0, -1);
		Global.team_1_spawn_positions[2] = Vector(15, 0, 1);
		Global.team_1_spawn_positions[3] = Vector(16, 0, 0);
		Global.team_1_spawn_positions[4] = Vector(16, 0, -1);
		Global.team_1_spawn_positions[5] = Vector(16, 0, 1);
		Global.team_2_spawn_positions[0] = Vector(-15, 0, 0);
		Global.team_2_spawn_positions[1] = Vector(-15, 0, -1);
		Global.team_2_spawn_positions[2] = Vector(-15, 0, 1);
		Global.team_2_spawn_positions[3] = Vector(-16, 0, 0);
		Global.team_2_spawn_positions[4] = Vector(-16, 0, -1);
		Global.team_2_spawn_positions[5] = Vector(-16, 0, 1);
	}
}

rule("Create bots")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create Dummy Bot(Hero(Cassidy), Team 2, 0, Global.team_2_spawn_positions[0], Global.team_2_spawn_direction);
	}
}

rule("Initialize player variables")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.bot_targeted_enemy = Null;
		Event Player.hud_notifications = Empty Array;
	}
}

rule("Configure hero properties - Cassidy")
{
	event
	{
		Ongoing - Each Player;
		All;
		Cassidy;
	}

	actions
	{
		Event Player.primary_fire_cooldown = 0.500;
		Event Player.primary_fire_max_range = 40;
	}
}

rule("When bot has spawned, begin targeting enemy")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.bot_targeted_enemy == Null;
	}

	actions
	{
		Event Player.bot_targeted_enemy = Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player)));
		If(Event Player.bot_targeted_enemy != Null && Is Dead(Event Player.bot_targeted_enemy));
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1} is targeting a dead player ({2})", Hero Icon String(
				Hero Of(Event Player)), String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1), Event Player.bot_targeted_enemy),
				Left, Global.hud_notifications_sort_order, Color(White), Color(White), Color(Yellow), None, Visible Always);
			Call Subroutine(AddLastTextToPlayerNotifications);
			Event Player.bot_targeted_enemy = Null;
			Event Player.bot_targeted_enemy = First Of(Filtered Array(Players in View Angle(Event Player, Opposite Team Of(Team Of(
				Event Player)), 45), Array Contains(All Living Players(Opposite Team Of(Team Of(Event Player))), Current Array Element)));
		End;
		If(Event Player.bot_targeted_enemy);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1} is now targeting {2}", Hero Icon String(Hero Of(
				Event Player)), String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1), Event Player.bot_targeted_enemy), Left,
				Global.hud_notifications_sort_order, Color(White), Color(White), Color(White), None, Visible Always);
			Call Subroutine(AddLastTextToPlayerNotifications);
		End;
		Wait(Global.targeting_interval, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("When bot takes damage, begin targeting attacker")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1} took damage from {2}", Hero Icon String(Hero Of(
			Event Player)), String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1), Attacker), Left,
			Global.hud_notifications_sort_order, Color(White), Color(White), Color(Yellow), None, Visible Always);
		Call Subroutine(AddLastTextToPlayerNotifications);
		Event Player.bot_targeted_enemy = Attacker;
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1} is now targeting {2}", Hero Icon String(Hero Of(
			Event Player)), String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1), Event Player.bot_targeted_enemy), Left,
			Global.hud_notifications_sort_order, Color(White), Color(White), Color(White), None, Visible Always);
		Call Subroutine(AddLastTextToPlayerNotifications);
	}
}

rule("When bot has targeted enemy, start facing target")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
		Event Player.bot_targeted_enemy != Null;
	}

	actions
	{
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.bot_targeted_enemy)),
			Global.bot_turn_rate, To World, Direction and Turn Rate);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1} has started facing {2}", Hero Icon String(Hero Of(
			Event Player)), String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1), Event Player.bot_targeted_enemy), Left,
			Global.hud_notifications_sort_order, Color(White), Color(White), Color(White), None, Visible Always);
		Call Subroutine(AddLastTextToPlayerNotifications);
	}
}

rule("When bot has no targeted enemy, stop facing target")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
		Event Player.bot_targeted_enemy == Null;
	}

	actions
	{
		Stop Facing(Event Player);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1} has no targeted enemy", Hero Icon String(Hero Of(
			Event Player)), String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1)), Left, Global.hud_notifications_sort_order,
			Color(White), Color(White), Color(White), None, Visible Always);
		Call Subroutine(AddLastTextToPlayerNotifications);
	}
}

rule("When bot ray cast hits enemy, fire weapon")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Hero Of(Event Player) != Hero(Hanzo);
		Ray Cast Hit Player(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player)
			* Event Player.primary_fire_max_range, All Living Players(Opposite Team Of(Team Of(Event Player))), Event Player, True)
			!= Null;
	}

	actions
	{
		Press Button(Event Player, Button(Primary Fire));
		Wait(Event Player.primary_fire_cooldown, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("When bot kills targeted enemy, stop targeting")
{
	event
	{
		Player Dealt Final Blow;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Event Player.bot_targeted_enemy == Victim;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1} dealt final blow to targeted enemy ({2})",
			Hero Icon String(Hero Of(Event Player)), String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1), Victim), Left,
			Global.hud_notifications_sort_order, Color(White), Color(White), Color(White), None, Visible Always);
		Call Subroutine(AddLastTextToPlayerNotifications);
		Event Player.bot_targeted_enemy = Null;
	}
}

rule("When bot dies, stop targeting")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1} died", Hero Icon String(Hero Of(Event Player)), String(
			"{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1)), Left, Global.hud_notifications_sort_order, Color(White), Color(
			White), Color(White), None, Visible Always);
		Call Subroutine(AddLastTextToPlayerNotifications);
		Event Player.bot_targeted_enemy = Null;
	}
}

rule("When bot sees no living enemies, reload weapon")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Ammo(Event Player, 0) < Max Ammo(Event Player, 0);
		Count Of(Filtered Array(Players in View Angle(Event Player, Opposite Team Of(Team Of(Event Player)), 45), Array Contains(
			All Living Players(Opposite Team Of(Team Of(Event Player))), Current Array Element))) == 0;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} {1} sees no enemies...reloading weapon", Hero Icon String(
			Hero Of(Event Player)), String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1)), Left,
			Global.hud_notifications_sort_order, Color(White), Color(White), Color(White), None, Visible Always);
		Call Subroutine(AddLastTextToPlayerNotifications);
		Press Button(Event Player, Button(Reload));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("HUD - game name")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Global.game_name, Null, Null, Top, 0, Color(Purple), Color(White), Color(White), None,
			Visible Always);
	}
}

rule("HUD - scoreboard spacing")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Null, Custom String(" "), Custom String(" "), Left, -99999, Color(White), Color(White),
			Color(White), None, Visible Never);
		Create HUD Text(All Players(All Teams), Null, Custom String(" "), Custom String(" "), Left, -99999, Color(White), Color(White),
			Color(White), None, Visible Never);
		Create HUD Text(All Players(All Teams), Null, Custom String(" "), Custom String(" "), Right, -99999, Color(White), Color(White),
			Color(White), None, Visible Never);
		Create HUD Text(All Players(All Teams), Null, Custom String(" "), Custom String(" "), Right, -99999, Color(White), Color(White),
			Color(White), None, Visible Never);
	}
}

rule("HUD - Team 1 scoreboard")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Custom String("{0} {1}: {2}", Hero Icon String(Hero Of(Event Player)), Is Dummy Bot(
			Event Player) ? String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1) : Event Player, Custom String(
			"{0} / {1} / {2}", Player Stat(Event Player, Final Blows), Player Stat(Event Player, Deaths), Player Stat(Event Player,
			Hero Damage Dealt))), Null, Null, Left, Player Stat(Event Player, All Damage Dealt) * -0.010, Color(White), Color(White),
			Color(White), Visible To Sort Order String and Color, Visible Always);
	}
}

rule("HUD - Team 2 scoreboard")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Custom String("{0} {1}: {2}", Hero Icon String(Hero Of(Event Player)), Is Dummy Bot(
			Event Player) ? String("{0} {1}", Custom String("Bot"), Slot Of(Event Player) + 1) : Event Player, Custom String(
			"{0} / {1} / {2}", Player Stat(Event Player, Final Blows), Player Stat(Event Player, Deaths), Player Stat(Event Player,
			Hero Damage Dealt))), Null, Null, Right, Player Stat(Event Player, All Damage Dealt) * -0.010, Color(White), Color(White),
			Color(White), Visible To Sort Order String and Color, Visible Always);
	}
}

rule("HUD - notifications spacing")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Null, Custom String(" "), Custom String(" "), Left,
			Global.hud_notifications_sort_order - 1, Color(White), Color(White), Color(White), None, Visible Always);
	}
}

rule("Add last text (with expiration time) to player HUD notifications")
{
	event
	{
		Subroutine;
		AddLastTextToPlayerNotifications;
	}

	actions
	{
		Modify Player Variable(Event Player, hud_notifications, Append To Array, Total Time Elapsed + Global.hud_notifications_duration);
		Modify Player Variable(Event Player, hud_notifications, Append To Array, Last Text ID);
	}
}

rule("Remove expired player HUD notifications")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		While(Count Of(Event Player.hud_notifications));
			If(Event Player.hud_notifications[0] > Total Time Elapsed);
				Break;
			End;
			Destroy HUD Text(Event Player.hud_notifications[1]);
			Modify Player Variable(Event Player, hud_notifications, Remove From Array By Index, 0);
			Modify Player Variable(Event Player, hud_notifications, Remove From Array By Index, 0);
		End;
		Wait(Global.hud_notifications_duration / 5, Ignore Condition);
		Loop;
	}
}
